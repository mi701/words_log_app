<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log.</title>
    
    <!-- Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/dexie@3/dist/dexie.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <!-- Config -->
    <script>
        tailwind.config = {
            // クラスベースのダークモードを有効化
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        shelter: {
                            // Light Mode: 【乾燥した土】 (Dry Earth)
                                    bg:     '#EBE9E4', // 乾いた漆喰や砂壁の色
                                    text:   '#635E59', // 乾いた木の皮の色
                                    chip:   '#DFDBD5', // 地層の一部のような色
                                    border: '#CEC8C0', // 砂に引いた線のような境界
                                    muted:  '#9C968F', // 風化した石の色
                            
                            // Dark Mode (夜モード: 未明の海)
                            dark: {
                                bg: '#2C3036',      // 深いスレートグレー
                                text: '#B0B6BE',    // 青みがかったオフホワイト
                                chip: '#3A3F47',    // 背景よりわずかに明るいグレー
                                border: '#454B54',  // 溶け込む境界線
                                muted: '#6C7582'    // 暗闇に沈むテキスト
                            }
                        }
                    },
                    animation: { 'in': 'fadeIn 0.3s ease-out' },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'scale(0.95)' },
                            '100%': { opacity: '1', transform: 'scale(1)' },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #e0ded9; border-radius: 4px; }
        /* ダークモード時のスクロールバー */
        .dark .custom-scrollbar::-webkit-scrollbar-thumb { background: #454B54; }
        
        body { font-family: "Helvetica Neue", Arial, sans-serif; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex justify-center h-screen w-full overflow-hidden transition-colors duration-300">

<!-- ルート要素: ダークモードのクラスはここに適用されます -->
<div id="root" class="w-full max-w-md h-full shadow-2xl overflow-hidden relative transition-colors duration-300"></div>

<script type="text/babel" data-type="module">
const { useState, useEffect, useRef, useMemo } = React;

// --- Database ---
const db = new Dexie("ShelterDB");
db.version(2).stores({
    logs: '++id, timestamp, dateString, is_ai_generated',
    user_words: '++id, word, category'
});

// --- Constants ---
const DEFAULT_WORDS = {
  feeling: [
    'だるい','めんどい','ねむい','つかれた','しんどい',
    '不安','むなしい','落ち着かない','イライラ','泣きたい',
    'まあまあ','悪くない','スッキリ','モヤモヤ','さみしい'
  ],
  body: [
    'ねむれない','おなかすいた','喉がかわいた','あたまいたい',
    '身体が重い','痛い','かゆい','息苦しい','目が痛い',
    'ふらふら','熱っぽい','冷えた','食べ過ぎた'
  ],
  state: [
    'ぼーっとする','なにもしたくない','帰りたい','うごけない',
    '余裕がない','焦ってる','暇','集中できない','考え事',
    '混乱してる','閉じこもりたい','誰かと話したい'
  ],
  action: [
    'テレビ見てた','スマホ見てた','外に出た','寝てた',
    '起きた','食べた','飲んだ','歩いた','お風呂入った',
    '薬飲んだ','横になった','掃除した','ボーッとした'
  ],
  env: [
    'あつい','さむい','うるさい','まぶしい','静か',
    '暗い','散らかってる','匂う','湿っぽい','乾燥してる',
    '居心地いい','居心地悪い','空気が重い'
  ],
  objects: [
    'スマホ','充電器','時計','おふとん','薬',
    '水','本','眼鏡','ゴミ','服','鍵','財布',
    'パソコン','お菓子'
  ],
  texture: [
    'ふわふわ','さらさら','べたべた','ざらざら',
    'ひんやり','ぬるい','かたい','やわらかい',
    'チクチク','じめじめ','カサカサ','ごわごわ'
  ],
  dist_space: [
    '近い','遠い','ずれている','せまい','広い',
    'ここ','どこか','閉じ込められた','開けてある',
    '隅っこ','真ん中','高すぎ','低すぎ'
  ],
  time: [
    '今','さっき','これから','ずっと','もうすぐ',
    '長い','早い','夜','朝','深夜','夕方','真夜中',
    '止まっている','あっという間'
  ],
  quantity: [
    'いっぱい','半分','少し','空っぽ','足りない',
    '多すぎる','ちょうどいい','ゼロ','増えた','減った',
    '残りわずか','あふれた'
  ]
};

// --- Component: Chip ---
const Chip = ({ children, onClick, active, loading }) => (
  <button
    onClick={onClick}
    disabled={loading}
    className={`px-4 py-2 rounded-full text-sm font-medium transition-all duration-300 transform active:scale-95 whitespace-nowrap 
    ${active 
        ? 'bg-shelter-text text-white dark:bg-shelter-dark-text dark:text-shelter-dark-bg shadow-sm' 
        : 'bg-shelter-chip text-shelter-text hover:bg-shelter-border border border-transparent dark:bg-shelter-dark-chip dark:text-shelter-dark-text dark:hover:bg-shelter-dark-border'} 
    ${loading ? 'opacity-50 animate-pulse' : ''}`}
  >
    {children}
  </button>
);

// --- Component: CanvasWord ---
const CanvasWord = ({ word, onClick }) => (
  <div
    onClick={onClick}
    // ダークモード対応: 背景色、文字色、ボーダー色、ホバー時の色を調整
    className="bg-white dark:bg-shelter-dark-bg px-3 py-1.5 rounded-lg border border-shelter-border dark:border-shelter-dark-border shadow-sm text-sm font-mono animate-in fade-in zoom-in duration-300 float-animation cursor-pointer text-shelter-text dark:text-shelter-dark-text hover:bg-stone-100 dark:hover:bg-stone-800 hover:border-stone-200 dark:hover:border-stone-700 transition-colors"
  >
    {word}
  </div>
);

// --- Main Application ---
const App = () => {
  const [activeTab, setActiveTab] = useState('record');
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [canvasWords, setCanvasWords] = useState([]);
  const [aiWords, setAiWords] = useState({});
  const [userWords, setUserWords] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [apiKey, setApiKey] = useState(() => localStorage.getItem('shelter_gemini_api_key') || '');
  const [showCustomInput, setShowCustomInput] = useState(false);
  const [debugInfo, setDebugInfo] = useState(null);
  
  // テーマ管理 (Light/Dark)
  const [theme, setTheme] = useState(() => localStorage.getItem('shelter_theme') || 'light');

  const customInputRef = useRef(null);

  const [aiDisabled, setAiDisabled] = useState(false);
  const [lastError, setLastError] = useState(null);
  const cachedModelName = useRef(null);

  // テーマ切り替え効果
  useEffect(() => {
    const root = document.getElementById('root');
    // bodyにも適用してブラウザ全体の背景色を合わせる
    if (theme === 'dark') {
        root.classList.add('dark');
        document.body.classList.add('dark');
        // ダークモード用の背景色クラス適用
        root.classList.add('bg-shelter-dark-bg');
        root.classList.remove('bg-shelter-bg');
    } else {
        root.classList.remove('dark');
        document.body.classList.remove('dark');
        // ライトモード用の背景色クラス適用
        root.classList.add('bg-shelter-bg');
        root.classList.remove('bg-shelter-dark-bg');
    }
    localStorage.setItem('shelter_theme', theme);
  }, [theme]);

  useEffect(() => {
    localStorage.setItem('shelter_gemini_api_key', apiKey);
    cachedModelName.current = null;
  }, [apiKey]);

  useEffect(() => {
    if (selectedCategory) {
      db.user_words
        .where('category').equals(selectedCategory)
        .toArray()
        .then(words => setUserWords(words.map(w => w.word)));
    }
  }, [selectedCategory]);

  const resolveModelName = async (key) => {
    if (cachedModelName.current) return cachedModelName.current;
    try {
        setDebugInfo("最新モデル情報を取得中...");
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
        if (!res.ok) throw new Error("モデルリスト取得失敗");
        const data = await res.json();
        const models = data.models || [];
        const flashModels = models.filter(m => 
            m.supportedGenerationMethods?.includes("generateContent") &&
            m.name.toLowerCase().includes("flash")
        );
        if (flashModels.length > 0) {
            flashModels.sort((a, b) => b.name.localeCompare(a.name));
            const bestModel = flashModels[0].name;
            cachedModelName.current = bestModel;
            return bestModel;
        }
    } catch (e) {
        console.warn("モデル動的解決エラー:", e);
    }
    return "models/gemini-1.5-flash"; 
  };

  const fetchWords = async (category) => {
    if (!apiKey || aiDisabled) return;
    setIsLoading(true);
    setLastError(null);

    try {
      const trimmedKey = apiKey.trim();
      const modelName = await resolveModelName(trimmedKey);
      setDebugInfo(`思考中...`);
      const url = `https://generativelanguage.googleapis.com/v1beta/${modelName}:generateContent?key=${trimmedKey}`;
      
      const promptText = `
        Generate 10 Japanese words/phrases for the category: "${category}".
        STRICT CONSTRAINTS:
        1. Format: Hiragana only. NO Romaji.
        2. Tone: Abstract, Soft, Passive Observation.
        3. NO Questions: (BAD: "はしる？", "いくの？")
        4. NO Future/Intent: (BAD: "いくよ", "たべるね")
        5. Tense Strategy: Use State ("つかれた"), Past ("歩いた"), Onomatopoeia ("ぼーっ").
        Return ONLY a JSON array of strings: ["word1", "word2", ...]
      `;

      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: promptText }] }],
          generationConfig: { response_mime_type: "application/json" }
        })
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        let errorMsg = `HTTP Error ${res.status}`;
        if (res.status === 400) errorMsg = "400 Bad Request (Key Invalid?)";
        if (res.status === 404) { cachedModelName.current = null; errorMsg = "404 Model Not Found"; }
        if (res.status === 429) { 
            setAiDisabled(true); 
            errorMsg = "429 Rate Limit Exceeded"; 
            setLastError(errorMsg);
            throw new Error(errorMsg); 
        }
        setLastError(errorMsg);
        throw new Error(errorMsg);
      }

      const data = await res.json();
      let resultWords = null;
      try {
        const text = data.candidates[0].content.parts[0].text;
        resultWords = JSON.parse(text);
      } catch (e) { throw new Error("解析エラー"); }

      if (Array.isArray(resultWords)) {
        const filteredWords = resultWords.filter(w => {
            if (typeof w !== 'string') return false;
            if (w.includes('?') || w.includes('？')) return false; 
            return true;
        });
        const finalWords = filteredWords.length >= 5 ? filteredWords : resultWords;
        setAiWords(prev => ({ ...prev, [category]: finalWords }));
        setDebugInfo(null);
      } else { throw new Error("データ形式エラー"); }
    } catch (error) {
      console.error("Gemini API Error:", error);
      setDebugInfo(`エラー: ${error.message}`);
      if (!lastError) setLastError(error.message);
    } finally { setIsLoading(false); }
  };

  const handleReload = () => { if (selectedCategory && apiKey) fetchWords(selectedCategory); };
  
  const handleCategoryClick = (catId) => { 
      setSelectedCategory(catId); 
      if (apiKey && !aiWords[catId] && !aiDisabled) fetchWords(catId); 
  };
  
  const handleAddWord = (word) => setCanvasWords(prev => [...prev, word]);
  const handleRemoveWord = (index) => { if (window.confirm('この言葉を取り除きますか？')) setCanvasWords(prev => prev.filter((_, i) => i !== index)); };
  
  const processCustomInput = async (val) => {
      if (!val) return;
      handleAddWord(val);
      if(customInputRef.current) customInputRef.current.value = '';
      setShowCustomInput(false);
      const isKnown = (DEFAULT_WORDS[selectedCategory] && DEFAULT_WORDS[selectedCategory].includes(val)) || (userWords.includes(val));
      if (!isKnown) {
          setTimeout(async () => {
              if (window.confirm(`「${val}」をポケットに入れますか？\n（次からこのカテゴリですぐ選べるようになります）`)) {
                  await db.user_words.add({ word: val, category: selectedCategory });
                  setUserWords(prev => [...prev, val]);
              }
          }, 300);
      }
  };

  const handleCustomInputKeyDown = (e) => {
    if (e.key === 'Enter') {
        processCustomInput(e.target.value.trim());
    }
  };

  const handleCustomInputSubmit = () => {
      if(customInputRef.current) {
          processCustomInput(customInputRef.current.value.trim());
      }
  };

  const handleSave = async () => {
    if (canvasWords.length === 0) return;
    const now = new Date();
    const log = { timestamp: now.getTime(), dateString: now.toISOString().split('T')[0], words: canvasWords, is_ai_generated: !!apiKey };
    await db.logs.add(log);
    setCanvasWords([]);
  };

  const DateHeader = () => {
    const today = new Date();
    const dateStr = today.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' });
    return (
        <div className="pt-6 px-6 pb-0 flex justify-between items-end">
            <h1 className="text-sm font-mono text-shelter-muted dark:text-shelter-dark-muted tracking-widest">{dateStr}</h1>
        </div>
    );
  };

  const RecordTab = () => {
    const [catPage, setCatPage] = useState(0);
    const itemsPerPage = 4;
    const categories = [
      { id: 'feeling', label: '気分' }, { id: 'body', label: '身体' }, { id: 'state', label: '状態' },
      { id: 'action', label: '動き' }, { id: 'env', label: '周囲' }, { id: 'objects', label: '物品' },
      { id: 'texture', label: '感触' }, { id: 'dist_space', label: '場所' }, { id: 'time', label: '時間' },
      { id: 'quantity', label: '分量' }
    ];
    const totalPages = Math.ceil(categories.length / itemsPerPage);
    const currentCats = categories.slice(catPage * itemsPerPage, (catPage + 1) * itemsPerPage);

    return (
      <div className="flex flex-col h-full">
        <DateHeader />
        
        {/* キャンバスエリア */}
        <div className="canvas-area p-6 flex-none min-h-[140px] max-h-[30vh] overflow-auto flex flex-wrap content-start gap-3 relative border-b border-shelter-border dark:border-shelter-dark-border/50">
          {canvasWords.length === 0 ? (
            <div className="w-full h-full flex items-center justify-center text-shelter-muted/30 dark:text-shelter-dark-muted/30 text-xs font-mono italic pointer-events-none">ここに言葉を置く</div>
          ) : (
            canvasWords.map((word,i) => <CanvasWord key={`${word}-${i}`} word={word} onClick={() => handleRemoveWord(i)} />)
          )}
        </div>

        {/* 入力デッキ */}
        <div className="input-deck flex-1 bg-white dark:bg-shelter-dark-bg p-8 flex flex-col gap-8 rounded-t-[2.5rem] shadow-[0_-8px_40px_-15px_rgba(0,0,0,0.08)] dark:shadow-[0_-8px_40px_-15px_rgba(0,0,0,0.3)] relative overflow-hidden transition-colors">
          
          <div className="flex items-center justify-between flex-none">
            {/* カテゴリページャー */}
            <div className="flex items-center gap-1 flex-1 min-w-0">
              <button 
                  disabled={catPage===0} 
                  onClick={()=>setCatPage(p=>p-1)} 
                  className={`flex-none w-8 h-8 rounded-full flex items-center justify-center transition-colors ${catPage===0?'text-gray-200 dark:text-gray-700 cursor-not-allowed':'bg-shelter-chip dark:bg-shelter-dark-chip text-shelter-text dark:text-shelter-dark-text hover:bg-shelter-border dark:hover:bg-shelter-dark-border'}`}
              >
                  <span className="material-symbols-outlined !text-base">chevron_left</span>
              </button>
              
              <div className="flex gap-1 justify-center flex-1 px-1">
                  {currentCats.map(cat=>(
                      <button 
                        key={cat.id} 
                        onClick={()=>handleCategoryClick(cat.id)} 
                        className={`text-sm font-semibold whitespace-nowrap transition-colors px-1 ${selectedCategory===cat.id?'text-shelter-text dark:text-shelter-dark-text border-b-2 border-shelter-text dark:border-shelter-dark-text':'text-shelter-muted dark:text-shelter-dark-muted hover:text-shelter-text dark:hover:text-shelter-dark-text'}`}
                      >
                          {cat.label}
                      </button>
                  ))}
              </div>
              
              <button 
                  disabled={catPage===totalPages-1} 
                  onClick={()=>setCatPage(p=>p+1)} 
                  className={`flex-none w-8 h-8 rounded-full flex items-center justify-center transition-colors ${catPage===totalPages-1?'text-gray-200 dark:text-gray-700 cursor-not-allowed':'bg-shelter-chip dark:bg-shelter-dark-chip text-shelter-text dark:text-shelter-dark-text hover:bg-shelter-border dark:hover:bg-shelter-dark-border'}`}
              >
                  <span className="material-symbols-outlined !text-base">chevron_right</span>
              </button>
            </div>
            
            <div className="flex flex-col items-center gap-2 pl-3 flex-none border-l border-shelter-border/30 dark:border-shelter-dark-border/30">
              <button onClick={handleSave} disabled={canvasWords.length===0} className={`w-12 h-12 rounded-full flex items-center justify-center transition-all ${canvasWords.length>0?'bg-shelter-text dark:bg-shelter-dark-text text-white dark:text-shelter-dark-bg shadow-md active:scale-95':'bg-shelter-chip dark:bg-shelter-dark-chip text-shelter-muted dark:text-shelter-dark-muted cursor-not-allowed opacity-50'}`} title="記録を保存">
                <span className="material-symbols-outlined !text-lg">done_all</span>
              </button>
              {debugInfo && (
                <div className="flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-shelter-chip dark:bg-shelter-dark-chip transition-all min-w-[80px] justify-center">
                  <span className={`w-1 h-1 rounded-full ${isLoading?'bg-shelter-text dark:bg-shelter-dark-text animate-ping':(aiDisabled?'bg-shelter-muted dark:bg-shelter-dark-muted':'bg-stone-400 dark:bg-stone-500')}`}></span>
                  <span className="text-[8px] font-medium tracking-tight text-shelter-muted dark:text-shelter-dark-muted whitespace-nowrap">{isLoading?'考え中':(aiDisabled?'休憩中':'エラー')}</span>
                </div>
              )}
            </div>
          </div>

          <div className="flex-1 overflow-y-auto custom-scrollbar flex flex-col gap-6">
            {!selectedCategory ? (
              <div className="flex items-center justify-center h-20 italic text-xs text-shelter-muted dark:text-shelter-dark-muted font-mono bg-shelter-chip/50 dark:bg-shelter-dark-chip/50 rounded-xl">カテゴリを選んでください</div>
            ) : (
                <>
                <div>
                    <div className="text-[10px] font-bold tracking-wider text-shelter-muted dark:text-shelter-dark-muted mb-2 px-1 flex items-center gap-2">
                        <span className="material-symbols-outlined !text-sm">bookmark</span>いつもの
                    </div>
                    <div className="flex flex-wrap gap-2">
                        <button onClick={()=>setShowCustomInput(true)} className="px-3 py-2 bg-shelter-chip dark:bg-shelter-dark-chip rounded-full flex items-center justify-center text-shelter-muted dark:text-shelter-dark-muted hover:bg-shelter-border dark:hover:bg-shelter-dark-border transition-colors border border-transparent" title="自分で入力">
                            <span className="material-symbols-outlined !text-sm">add</span>
                        </button>
                        
                        {showCustomInput && (
                            <div className="flex items-center gap-2 animate-in fade-in slide-in-from-left-2 duration-200">
                                <input 
                                    ref={customInputRef}
                                    autoFocus 
                                    id="custom-word-input" 
                                    className="bg-white dark:bg-shelter-dark-bg border-2 border-shelter-border/50 dark:border-shelter-dark-border/50 text-shelter-text dark:text-shelter-dark-text px-3 py-1.5 rounded-full text-sm outline-none focus:border-shelter-text/20 dark:focus:border-shelter-dark-text/20 transition-colors w-32" 
                                    placeholder="自由入力..." 
                                    onKeyDown={handleCustomInputKeyDown} 
                                    onBlur={(e)=>{if(!e.target.value.trim()) setShowCustomInput(false);}}
                                />
                                <button onClick={handleCustomInputSubmit} className="w-8 h-8 rounded-full bg-shelter-text dark:bg-shelter-dark-text text-white dark:text-shelter-dark-bg flex items-center justify-center shadow-sm hover:opacity-90 transition-opacity flex-none">
                                    <span className="material-symbols-outlined !text-sm">check</span>
                                </button>
                            </div>
                        )}
                        {DEFAULT_WORDS[selectedCategory].map(word=><Chip key={`def-${word}`} onClick={()=>handleAddWord(word)}>{word}</Chip>)}
                    </div>
                </div>

                {userWords.length > 0 && (
                    <div className="border-t border-shelter-border/40 dark:border-shelter-dark-border/40 pt-4 mt-2">
                        <div className="text-[10px] font-bold tracking-wider text-shelter-muted dark:text-shelter-dark-muted mb-2 px-1 flex items-center gap-2">
                            <span className="material-symbols-outlined !text-sm">inventory_2</span>ポケット
                        </div>
                        <div className="flex flex-wrap gap-2">
                             {userWords.map((word, idx) => (
                                 <Chip key={`user-${idx}`} onClick={()=>handleAddWord(word)}>{word}</Chip>
                             ))}
                        </div>
                    </div>
                )}

                {apiKey && (
                    <div className="border-t border-shelter-border/40 dark:border-shelter-dark-border/40 pt-4 mt-2">
                        <div className="flex items-center justify-between mb-2 px-1">
                            <div className="text-[10px] font-bold tracking-wider text-shelter-muted dark:text-shelter-dark-muted flex items-center gap-2">
                                <span className="material-symbols-outlined !text-sm">auto_stars</span>AIのひらめき
                            </div>
                            <button onClick={handleReload} disabled={isLoading || aiDisabled} className={`w-8 h-8 rounded-full flex items-center justify-center text-shelter-muted dark:text-shelter-dark-muted hover:bg-shelter-chip dark:hover:bg-shelter-dark-chip transition-all ${isLoading?'animate-spin opacity-50':''}`} title="リロード">
                                <span className="material-symbols-outlined !text-base">refresh</span>
                            </button>
                        </div>
                        <div className="flex flex-wrap gap-2 min-h-[40px]">
                            {aiWords[selectedCategory] ? (
                                aiWords[selectedCategory].map(word=><Chip key={`ai-${word}`} loading={isLoading} onClick={()=>handleAddWord(word)}>{word}</Chip>)
                            ) : (
                                <div className="text-[10px] text-shelter-muted dark:text-shelter-dark-muted italic px-2 py-1">
                                    {isLoading ? '生成しています...' : (aiDisabled ? 'AI休憩中' : '選択すると提案します')}
                                </div>
                            )}
                        </div>
                    </div>
                )}
                </>
            )}
          </div>
        </div>
      </div>
    );
  };

  const ObserveTab = () => {
    const [records,setRecords] = useState([]);
    const [mode,setMode] = useState('distill');
    
    const stats = useMemo(() => {
        if (!records.length) return null;
        const activity = [];
        const today = new Date();
        for(let i=13; i>=0; i--){
            const d = new Date(today);
            d.setDate(today.getDate() - i);
            const dateStr = d.toISOString().split('T')[0];
            const hasLog = records.some(r => r.dateString === dateStr);
            activity.push({ date: dateStr, hasLog });
        }
        const wordCount = {};
        records.forEach(r => { r.words.forEach(w => { wordCount[w] = (wordCount[w] || 0) + 1; }); });
        const ranking = Object.entries(wordCount).sort((a,b) => b[1] - a[1]).slice(0, 5);
        return { activity, ranking };
    }, [records]);

    useEffect(()=>{db.logs.orderBy('timestamp').reverse().toArray().then(all=>setRecords(all));}, []);

    return (
      <div className="p-8 h-full bg-shelter-bg dark:bg-shelter-dark-bg overflow-auto transition-colors">
        <DateHeader />
        
        {records.length > 0 && stats && (
            <div className="mb-8 mt-6 grid grid-cols-2 gap-4">
                {/* 足あと */}
                <div className="bg-white dark:bg-shelter-dark-chip p-4 rounded-2xl border border-shelter-border/50 dark:border-shelter-dark-border/50 shadow-sm transition-colors">
                    <div className="text-[10px] font-bold tracking-wider text-shelter-muted dark:text-shelter-dark-muted mb-3">足あと (14days)</div>
                    <div className="flex justify-between items-center">
                        {stats.activity.map((day, i) => (
                            <div key={day.date} title={day.date} className={`w-2 h-2 rounded-full transition-all ${day.hasLog ? 'bg-shelter-text dark:bg-shelter-dark-text scale-110' : 'bg-shelter-chip dark:bg-stone-700'}`}></div>
                        ))}
                    </div>
                </div>
                {/* ランキング */}
                <div className="bg-white dark:bg-shelter-dark-chip p-4 rounded-2xl border border-shelter-border/50 dark:border-shelter-dark-border/50 shadow-sm overflow-hidden transition-colors">
                    <div className="text-[10px] font-bold tracking-wider text-shelter-muted dark:text-shelter-dark-muted mb-2">よく出る言葉</div>
                    <div className="flex flex-col gap-1">
                        {stats.ranking.map((item, i) => (
                            <div key={item[0]} className="flex justify-between items-center text-xs text-shelter-text dark:text-shelter-dark-text"><span className="truncate">{item[0]}</span><span className="text-[10px] text-shelter-muted dark:text-shelter-dark-muted font-mono">x{item[1]}</span></div>
                        ))}
                        {stats.ranking.length === 0 && <span className="text-[10px] text-shelter-muted dark:text-shelter-dark-muted italic">記録なし</span>}
                    </div>
                </div>
            </div>
        )}

        <div className="flex justify-between items-end mb-6 border-b border-shelter-border/30 dark:border-shelter-dark-border/30 pb-2">
          <h2 className="text-xs font-mono text-shelter-muted dark:text-shelter-dark-muted tracking-widest uppercase">Logs</h2>
          <div className="flex gap-4 text-[10px] font-mono">
            <button onClick={()=>setMode('distill')} className={mode==='distill'?'text-shelter-text dark:text-shelter-dark-text font-bold border-b border-shelter-text dark:border-shelter-dark-text':'text-shelter-muted dark:text-shelter-dark-muted'}>抽出</button>
            <button onClick={()=>setMode('sediment')} className={mode==='sediment'?'text-shelter-text dark:text-shelter-dark-text font-bold border-b border-shelter-text dark:border-shelter-dark-text':'text-shelter-muted dark:text-shelter-dark-muted'}>堆積</button>
          </div>
        </div>

        {records.length===0?<div className="text-sm text-shelter-muted dark:text-shelter-dark-muted font-mono text-center mt-10 opacity-50">まだ記録がありません</div>:(
          <div className={mode==='distill'?"space-y-8":"flex flex-wrap-reverse gap-x-2 gap-y-2 items-end content-end min-h-[200px]"}>
            {records.map(log=>(
              <div key={log.id} className={mode==='distill'?"group relative pl-4 border-l-2 border-shelter-chip dark:border-shelter-dark-chip hover:border-shelter-border dark:hover:border-shelter-dark-border transition-colors":"contents"}>
                {mode==='distill' && (
                    <div className="text-[10px] font-mono text-shelter-muted dark:text-shelter-dark-muted mb-1.5 opacity-70">
                        {log.dateString} <span className="opacity-30">|</span> {new Date(log.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                    </div>
                )}
                <div className={mode==='distill'?"flex flex-wrap gap-2":"contents"}>
                  {log.words.map((w,i)=> (
                      <span key={i} className={mode==='distill'
                        ? "text-sm text-shelter-text dark:text-shelter-dark-text bg-white dark:bg-shelter-dark-chip px-2 py-0.5 rounded border border-shelter-chip dark:border-shelter-dark-border transition-colors"
                        : "text-xs px-2 py-1 bg-white dark:bg-shelter-dark-chip text-shelter-text dark:text-shelter-dark-text border border-shelter-border dark:border-shelter-dark-border rounded opacity-70 hover:opacity-100 transition-all"}>
                        {w}
                      </span>
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  const SettingsTab = () => {
    // テーマ切り替えハンドラ
    const toggleTheme = () => {
        setTheme(prev => prev === 'light' ? 'dark' : 'light');
    };

    const handleExport = async ()=>{
      const all = await db.logs.toArray();
      const blob = new Blob([JSON.stringify(all,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const date = new Date().toISOString().split('T')[0];
      a.href = url;
      a.download = "shelter_backup_" + date + ".json";
      a.click();
    };
    
    const handleClear = async () => { 
        if(confirm('すべての記録を消去しますか？（元に戻せません）')){ 
            await db.logs.clear(); 
            await db.user_words.clear(); 
            alert('データを消去しました'); 
            window.location.reload(); 
        }
    };

    return (
      <div className="p-8 h-full bg-shelter-bg dark:bg-shelter-dark-bg overflow-auto space-y-12 transition-colors">
        <h2 className="text-xs font-mono text-shelter-muted dark:text-shelter-dark-muted tracking-widest uppercase mb-8">System</h2>
        
        {/* Appearance Section (New) */}
        <section className="space-y-4">
          <label className="block text-sm font-medium text-shelter-text dark:text-shelter-dark-text">Appearance</label>
          <button 
            onClick={toggleTheme}
            className="w-full bg-white dark:bg-shelter-dark-chip border border-shelter-border dark:border-shelter-dark-border p-3 rounded-lg flex items-center justify-between group hover:border-shelter-text dark:hover:border-shelter-dark-text transition-all"
          >
            <span className="text-sm font-mono text-shelter-text dark:text-shelter-dark-text flex items-center gap-2">
                <span className="material-symbols-outlined !text-lg">{theme === 'light' ? 'light_mode' : 'dark_mode'}</span>
                {theme === 'light' ? '朝モード (Light)' : '夜モード (Dark)'}
            </span>
            <span className="material-symbols-outlined !text-lg text-shelter-muted dark:text-shelter-dark-muted group-hover:text-shelter-text dark:group-hover:text-shelter-dark-text transition-colors">
                toggle_{theme === 'light' ? 'off' : 'on'}
            </span>
          </button>
        </section>

        <section className="space-y-4">
          <label className="block text-sm font-medium text-shelter-text dark:text-shelter-dark-text">Gemini API Key</label>
          <div className="relative">
            <input type="password" className="w-full bg-white dark:bg-shelter-dark-chip border border-shelter-border dark:border-shelter-dark-border p-3 rounded-lg text-sm font-mono outline-none shadow-sm focus:border-shelter-text dark:focus:border-shelter-dark-text text-shelter-text dark:text-shelter-dark-text transition-colors pr-10 placeholder-shelter-muted dark:placeholder-stone-600" placeholder="AI を有効にするにはキーを入力..." value={apiKey} onChange={e=>setApiKey(e.target.value)} />
            {apiKey && <div className="absolute right-3 top-1/2 -translate-y-1/2 text-shelter-text dark:text-shelter-dark-text opacity-50 flex items-center gap-1"><span className="material-symbols-outlined !text-sm">check_circle</span><span className="text-[10px] font-mono">SAVED</span></div>}
          </div>
          <p className="text-[10px] text-shelter-muted dark:text-shelter-dark-muted leading-relaxed">キーを設定すると、AI がカテゴリに合わせて言葉を提案します。<br/>入力した内容は自動的に保存されます（localStorage）。</p>
        </section>

        <section className="space-y-4 pt-8 border-t border-shelter-border dark:border-shelter-dark-border">
            <div className="flex items-center justify-between">
                <h3 className="text-sm font-medium text-shelter-text dark:text-shelter-dark-text">AI Status</h3>
                <span className={`text-[10px] font-mono px-2 py-0.5 rounded ${aiDisabled ? 'bg-stone-100 text-stone-500 dark:bg-stone-800 dark:text-stone-400' : 'bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-300'}`}>
                   {aiDisabled ? 'PAUSED' : 'ACTIVE'}
                </span>
            </div>
            <button
                onClick={() => {
                    setAiDisabled(false);
                    setLastError(null);
                    cachedModelName.current = null;
                    setDebugInfo("AIステータスをリセットしました");
                    setTimeout(() => setDebugInfo(null), 3000);
                }}
                disabled={!aiDisabled}
                className={`w-full py-3 px-4 rounded-lg text-xs font-mono transition-colors flex items-center justify-center gap-2 ${aiDisabled ? 'bg-shelter-text text-white shadow-md hover:bg-shelter-text/90 dark:bg-shelter-dark-text dark:text-shelter-dark-bg' : 'bg-white dark:bg-shelter-dark-chip border border-shelter-border dark:border-shelter-dark-border text-shelter-muted dark:text-shelter-dark-muted cursor-default'}`}
            >
                <span className="material-symbols-outlined !text-sm">restart_alt</span>AI リセット / 再開
            </button>
            {lastError && (
                <div className="mt-2 p-2 bg-stone-50 dark:bg-stone-800 border border-stone-200 dark:border-stone-700 rounded text-[10px] font-mono text-stone-500 dark:text-stone-400 break-all">Last Error: {lastError}</div>
            )}
            <p className="text-[10px] text-shelter-muted dark:text-shelter-dark-muted leading-relaxed mt-2">レート制限(429)やエラーが続くとAIは自動的に一時停止します。<br/>時間を置いてからリセットボタンを押すと再開できます。</p>
        </section>

        <section className="space-y-4 pt-8 border-t border-shelter-border dark:border-shelter-dark-border">
          <h3 className="text-sm font-medium text-shelter-text dark:text-shelter-dark-text">Data Management</h3>
          <div className="grid grid-cols-2 gap-4">
            <button onClick={handleExport} className="bg-white dark:bg-shelter-dark-chip border border-shelter-border dark:border-shelter-dark-border py-3 rounded-lg text-xs font-mono text-shelter-text dark:text-shelter-dark-text hover:bg-shelter-chip dark:hover:bg-shelter-dark-border transition-colors">Export JSON</button>
            <button onClick={handleClear} className="bg-white dark:bg-shelter-dark-chip border border-shelter-border dark:border-shelter-dark-border py-3 rounded-lg text-xs font-mono text-shelter-text dark:text-shelter-dark-text hover:bg-stone-100 dark:hover:bg-stone-800 transition-colors">Clear All</button>
          </div>
        </section>
      </div>
    );
  };

  return (
    <div className="h-screen flex flex-col transition-colors duration-300">
      <div className="flex-1 relative overflow-hidden bg-shelter-bg dark:bg-shelter-dark-bg">
        {activeTab==='record' && <RecordTab />}
        {activeTab==='observe' && <ObserveTab />}
        {activeTab==='settings' && <SettingsTab />}
      </div>
      <div className="flex justify-center gap-12 p-4 border-t border-shelter-border/30 dark:border-shelter-dark-border/30 bg-white dark:bg-shelter-dark-chip z-10 transition-colors">
        {[
          { id: 'record', icon: 'edit_note', label: '記録' },
          { id: 'observe', icon: 'grid_view', label: '観察' },
          { id: 'settings', icon: 'tune', label: '設定' }
        ].map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex flex-col items-center gap-1 w-14 transition-colors ${activeTab === tab.id ? 'text-shelter-text dark:text-shelter-dark-text' : 'text-shelter-muted dark:text-shelter-dark-muted hover:text-shelter-text dark:hover:text-shelter-dark-text/70'}`}
          >
            <span className={`material-symbols-outlined !text-2xl transition-transform duration-300 ${activeTab === tab.id ? '-translate-y-0.5' : ''}`}>{tab.icon}</span>
            <span className="text-[10px] font-bold tracking-widest">{tab.label}</span>
          </button>
        ))}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>